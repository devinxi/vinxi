/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
// import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
// import { folder, useControls } from "@/lib/leva";
// import * as React from "solid-react-compat";
// import { useSpring } from "@react-spring/core";
// import { a } from "@react-spring/three";
// import { Color, PieceSymbol, Square } from "@/lib/chess/types";
// import { useAtom } from "jotai";
// import { $ } from "src/atoms";
// import { useHover } from "../../lib/useHover";
import { BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK } from "@/lib/lib/chess";
import { useGLTF } from "solid-drei";
import { useRef } from "solid-react-compat";
import { Show, Suspense } from "solid-js";
import { mergeProps, JSX } from "solid-js";
import { folder, useControls } from "@/lib/lib/leva";
import { useTheatre } from "./App";
import { useTheatreControls } from "./useTheatreControls";

type GLTFResult = GLTF & {
  nodes: {
    Rook: THREE.Mesh;
    Queen: THREE.Mesh;
    Bishop: THREE.Mesh;
    King: THREE.Mesh;
    Knight: THREE.Mesh;
    Pawn: THREE.Mesh;
  };
  materials: {
    white_piece: THREE.MeshStandardMaterial;
    black_piece: THREE.MeshStandardMaterial;
  };
};

const pieceMap = {
  [PAWN]: "Pawn",
  [ROOK]: "Rook",
  [QUEEN]: "Queen",
  [KING]: "King",
  [KNIGHT]: "Knight",
  [BISHOP]: "Bishop"
} as const;

export function Piece(props) {
  props = mergeProps(
    {
      piece: QUEEN,
      color: BLACK,
      square: "a1",
      position: [0, 0, 0]
    },
    props
  );

  const controls = useControls("piece", {
    color: folder({ black: "#414141", white: "#c4bdbd" })
  });

  const object = useTheatreControls("piece", {
    y: 0,
    rotateY: -Math.PI / 2
  });

  // const [x, y, z] = position;

  // const ref = React.useRef<THREE.Object3D>();

  // useFrame(() => {});

  // const [isSquareHovered, setIsSquareHovered] = useAtom(
  //   $.isHoveredSquare(square)
  // );

  // const [selectedSquare, setSelectedSquare] = useAtom($.selectedSquare);
  // const isSelected = selectedSquare === square;
  // const [_, bind] = useHover({
  //   onPointerEnter: (e) => {
  //     setIsSquareHovered(true);
  //   },
  //   onPointerLeave: (e) => {
  //     setIsSquareHovered(false);
  //   },
  // });
  // const turn = useAtomValue($.turn);
  // const isSelectable = color === turn;

  // const { spring: hoverSpring } = useSpring({
  //   spring: (isSquareHovered && isSelectable) || isSelected ? 1 : 0,
  //   config: { mass: 5, tension: 400, friction: 50, precision: 0.0001 },
  // });

  // const positionY = hoverSpring.to([0, 1], [y, y + 0.3]);
  // const rotationY = hoverSpring.to([0, 1], [0, 0.5]);

  return (
    <group
      position={[props.position[0], props.position[1] + object.y, props.position[2]]}
      rotation-y={object.rotateY}
    >
      <PieceModel
        // {...bind}
        piece={pieceMap[props.piece]}
        onPointerDown={() => {
          // if (color === turn) {
          //   setSelectedSquare(square);
          // }
        }}
        rotation={[
          -Math.PI / 4,
          0,
          0
          // props.color === BLACK ? (5 / 4) * Math.PI : Math.PI / 4
        ]}
        // material={props.color === BLACK ? "black_piece" : "white_piece"}
        // {...props}
      >
        <meshLambertMaterial
          reflectivity={10}
          color={props.color === BLACK ? controls.black : controls.white}
        />
      </PieceModel>
    </group>
  );
}

type PieceType = keyof GLTFResult["nodes"];

export function PieceModel(
  props: JSX.IntrinsicElements["group"] & {
    piece: PieceType;
    material?: keyof GLTFResult["materials"];
  }
) {
  const group = useRef<THREE.Group>();
  const [data] = useGLTF<any, GLTFResult>("/low_poly_chess_set/pieces.glb");

  return (
    <group ref={el => (group.current = el)} {...props} dispose={null}>
      <group name="Piece">
        <Show when={data()} fallback={null}>
          <mesh
            name={props.piece}
            castShadow
            receiveShadow
            position={props.position}
            rotation={props.rotation}
            geometry={data()?.nodes[props.piece].geometry}
            {...(props.material ? { material: data()?.materials[props.material] } : {})}
            userData={{ name: props.piece }}
          >
            {props.children}
          </mesh>
        </Show>
      </group>
    </group>
  );
}

// useGLTF.preload("/low_poly_chess_set/pieces.glb");
