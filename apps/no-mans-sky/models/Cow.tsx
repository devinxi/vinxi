/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import * as React, { useRef } from "solid-js";
import { Html, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { AnimationClip } from "three";
import { useControls } from "@/leva";
import { atomFamily, useAtomValue } from "jotai/utils";
import { atom } from "jotai";
import { $, useCharacter } from "../atoms";

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.SkinnedMesh;
    Cube_1: THREE.SkinnedMesh;
    Cube_2: THREE.SkinnedMesh;
    Cube_3: THREE.SkinnedMesh;
    Cube_4: THREE.SkinnedMesh;
    Cube_5: THREE.SkinnedMesh;
    Cube_6: THREE.SkinnedMesh;
    Body: THREE.Bone;
    IKBackLegL: THREE.Bone;
    IKFrontLegL: THREE.Bone;
    IKBackLegR: THREE.Bone;
    IKFrontLegR: THREE.Bone;
  };
  materials: {
    Main: THREE.MeshStandardMaterial;
    Main_Light: THREE.MeshStandardMaterial;
    Hooves: THREE.MeshStandardMaterial;
    Muzzle: THREE.MeshStandardMaterial;
    Eye_Black: THREE.MeshStandardMaterial;
    Eye_White: THREE.MeshStandardMaterial;
    Horns: THREE.MeshStandardMaterial;
  };
};

type ActionName =
  | "Attack_Headbutt"
  | "Attack_Kick"
  | "Death"
  | "Eating"
  | "Gallop"
  | "Gallop_Jump"
  | "Idle"
  | "Idle_2"
  | "Idle_Headlow"
  | "Idle_HitReact_Left"
  | "Idle_HitReact_Right"
  | "Jump_toIdle"
  | "Walk";

interface GLTFActions extends AnimationClip {
  name: ActionName;
}

import { Loader } from "three";
// @ts-ignore
import { GLTFLoader, DRACOLoader, MeshoptDecoder } from "three-stdlib";
import { useFrame, useGraph, useLoader } from "solid-three";
import { useKeyboardInput } from "src/Keyboard";

function onEnter<T extends string>(
  state: T,
  prevState: T,
  onEnter: { [k in T]?: (prevState: T) => void }
) {
  onEnter[state]?.(prevState);
}

function onExit<T extends string>(
  state: T,
  prevState: T,
  onExit: { [k in T]?: (prevState: T) => void }
) {
  onExit[state]?.(prevState);
}

export function Character() {
  const state = useCharacter((s) => s.state);
  const object = useAtomValue($.gltfAsset("/animals/Cow.gltf"));
  const { actions, ref } = useAnimations<GLTFActions>(object.animations as any);

  const controls = useCharacterController(ref.current!, actions);

  return (
    <>
      <CowModel
        ref={ref}
        gltf={object}
        // position={controls.position}
        rotation={[0, Math.PI, 0]}
        onPointerDown={() => {
          // dispatch({ type: "MOVE" });
        }}
      />
      <Html position={[-15, 2, 6]}>
        <h1>{state}</h1>
      </Html>
    </>
  );
}

const CowModel = React.forwardRef(function CowModel(
  props: JSX.IntrinsicElements["group"] & { gltf: GLTF },
  ref: React.Ref<THREE.Object3D | null | undefined>
) {
  const { nodes, materials } = useGraph(props.gltf.scene) as GLTFResult;

  return (
    <group ref={ref} {...props} dispose={null}>
      <group name="Scene">
        <group name="AnimalArmature" userData={{ name: "AnimalArmature" }}>
          <primitive object={nodes.Body} />
          <primitive object={nodes.IKBackLegL} />
          <primitive object={nodes.IKFrontLegL} />
          <primitive object={nodes.IKBackLegR} />
          <primitive object={nodes.IKFrontLegR} />
          <group name="Cow" userData={{ name: "Cow" }}>
            <skinnedMesh
              name="Cube"
              geometry={nodes.Cube.geometry}
              material={materials.Main}
              skeleton={nodes.Cube.skeleton}
            />
            <skinnedMesh
              name="Cube_1"
              geometry={nodes.Cube_1.geometry}
              material={materials.Main_Light}
              skeleton={nodes.Cube_1.skeleton}
            />
            <skinnedMesh
              name="Cube_2"
              geometry={nodes.Cube_2.geometry}
              material={materials.Hooves}
              skeleton={nodes.Cube_2.skeleton}
            />
            <skinnedMesh
              name="Cube_3"
              geometry={nodes.Cube_3.geometry}
              material={materials.Muzzle}
              skeleton={nodes.Cube_3.skeleton}
            />
            <skinnedMesh
              name="Cube_4"
              geometry={nodes.Cube_4.geometry}
              material={materials.Eye_Black}
              skeleton={nodes.Cube_4.skeleton}
            />
            <skinnedMesh
              name="Cube_5"
              geometry={nodes.Cube_5.geometry}
              material={materials.Eye_White}
              skeleton={nodes.Cube_5.skeleton}
            />
            <skinnedMesh
              name="Cube_6"
              geometry={nodes.Cube_6.geometry}
              material={materials.Horns}
              skeleton={nodes.Cube_6.skeleton}
            />
          </group>
        </group>
      </group>
    </group>
  );
});

const decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0);
const acceleration = new THREE.Vector3(1, 0.25, 500.0);

export function useCharacterController(
  ref: THREE.Object3D,
  actions: {
    Attack_Headbutt: THREE.AnimationAction | null;
    Attack_Kick: THREE.AnimationAction | null;
    Death: THREE.AnimationAction | null;
    Eating: THREE.AnimationAction | null;
    Gallop: THREE.AnimationAction | null;
    Gallop_Jump: THREE.AnimationAction | null;
    Idle: THREE.AnimationAction | null;
    Idle_2: THREE.AnimationAction | null;
    Idle_Headlow: THREE.AnimationAction | null;
    Idle_HitReact_Left: THREE.AnimationAction | null;
    Idle_HitReact_Right: THREE.AnimationAction | null;
    Jump_toIdle: THREE.AnimationAction | null;
    Walk: THREE.AnimationAction | null;
  }
) {
  const controls = useControls("character", {
    moveSpeed: 0.02,
  });

  const [{ rotation, position, velocity }] = React.useState(() => ({
    rotation: new THREE.Quaternion(),
    position: new THREE.Vector3(),
    velocity: new THREE.Vector3(0, 0, 0),
  }));

  React.useLayoutEffect(() => {
    if (ref) {
      position.copy(ref.position);
      rotation.copy(ref.quaternion);
    }
  }, [ref, rotation, position]);

  function getAction(
    state: ReturnType<typeof useCharacter["getState"]>["state"]
  ) {
    return actions[
      (
        {
          idle: "Idle",
          walk: "Walk",
          run: "Gallop",
          attack: "Attack_Headbutt",
        } as const
      )[state]
    ];
  }

  useFrame(() => {
    const { state } = useCharacter.getState();
    const { controls } = useKeyboardInput.getState();

    var nextState = state;

    switch (state) {
      case "idle": {
        if (controls.forward || controls.backward) {
          nextState = "walk";
        }
        break;
      }
      case "walk": {
        if (controls.shift) {
          nextState = "run";
        } else if (!controls.forward && !controls.backward) {
          nextState = "idle";
        }
        break;
      }
      case "run": {
        if (!controls.shift) {
          nextState = "walk";
        }
        break;
      }
    }

    if (nextState != state) {
      onExit(state, nextState, {});
      onEnter(nextState, state, {
        idle: (prevState) => {
          let idleAction = actions["Idle"]!;
          if (prevState) {
            idleAction.time = 0;
            idleAction.enabled = true;
            idleAction.setEffectiveWeight(1.0);
            idleAction.setEffectiveTimeScale(1.0);
            idleAction?.crossFadeFrom(getAction(prevState)!, 0.5, true);
            idleAction.play();
          } else {
            idleAction.play();
          }
        },
        walk: (prevState) => {
          let walkAction = actions["Walk"]!;
          walkAction.enabled = true;
          if (prevState === "run") {
            let runAction = getAction("run")!;
            walkAction.time =
              runAction.time *
              (walkAction.getClip().duration / runAction.getClip().duration);
          } else {
            walkAction.time = 0.0;
            walkAction.setEffectiveWeight(1.0);
            walkAction.setEffectiveTimeScale(1.0);
          }
          walkAction?.crossFadeFrom(getAction(prevState)!, 0.5, true);
          walkAction.play();
        },
        run: (prevState) => {
          let runAction = getAction("run")!;
          runAction.enabled = true;
          if (prevState === "walk") {
            let walkAction = getAction("walk")!;
            runAction.time =
              walkAction.time *
              (runAction.getClip().duration / walkAction.getClip().duration);
          } else {
            runAction.time = 0.0;
            runAction.setEffectiveWeight(1.0);
            runAction.setEffectiveTimeScale(1.0);
          }
          runAction?.crossFadeFrom(getAction(prevState)!, 0.5, true);
          runAction.play();
        },
      });

      console.log("transition", state, nextState);
      useCharacter.setState({ state: nextState });
    }
  });

  useFrame((s) => {
    const { controls } = useKeyboardInput.getState();

    let timeInSeconds = Math.min(s.clock.getElapsedTime(), 0.01);
    const frameDecceleration = new THREE.Vector3(
      velocity.x * decceleration.x,
      velocity.y * decceleration.y,
      velocity.z * decceleration.z
    );
    frameDecceleration.multiplyScalar(timeInSeconds);
    frameDecceleration.z =
      Math.sign(frameDecceleration.z) *
      Math.min(Math.abs(frameDecceleration.z), Math.abs(velocity.z));
    velocity.add(frameDecceleration);

    if (controls.forward) {
      velocity.z += 10 * acceleration.z * timeInSeconds;
    }
    if (controls.backward) {
      velocity.z -= 10 * acceleration.z * timeInSeconds;
    }

    if (controls.left) {
      _A.set(0, 1, 0);
      _Q.setFromAxisAngle(_A, 4 * Math.PI * timeInSeconds * acceleration.x);
      ref.quaternion.multiply(_Q);
    }
    if (controls.right) {
      _A.set(0, 1, 0);
      _Q.setFromAxisAngle(_A, 4 * -Math.PI * timeInSeconds * acceleration.x);
      ref.quaternion.multiply(_Q);
    }

    rotation.slerp(ref.quaternion, 0.15);

    //forward.y = 0;
    const forward = new THREE.Vector3(0, 0, 1);
    forward.applyQuaternion(ref.quaternion);
    forward.normalize();

    const sideways = new THREE.Vector3(1, 0, 0);
    sideways.applyQuaternion(ref.quaternion);
    sideways.normalize();

    sideways.multiplyScalar(velocity.x * timeInSeconds);
    forward.multiplyScalar(velocity.z * timeInSeconds);

    ref.position.add(forward);
    ref.position.add(sideways);

    position.lerp(ref.position, 0.15);

    // useViewer.getState().position.copy(position);

    ref.position.copy(position);
    ref.quaternion.copy(rotation);
  });
}

const _Q = new THREE.Quaternion();
const _A = new THREE.Vector3();
